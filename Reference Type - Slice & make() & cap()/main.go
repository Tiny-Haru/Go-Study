package main

import "fmt"

func main() {
	//배열은 길이가 고정되어 있고, 그 안에 연속적으로 데이터를 저장하지만 크기를 동적으로 증가시키거나 특정 부분을 발췌하는 등의 기능은 가지고 있지 않음.

	//slice는 내부적으로 동적 배열의 개념으로 만들어졌기에 필요에 따라 크기를 변경할 수 있음.
	//append와 같은 빠르고 효과적으로 크기를 조절할 수 있는 내장 함수를 제공하고, 메모리가 연속적으로 할당되게 때문에
	//인덱싱, 반복과 Garbage collection 에서 매우 유리하기에 배열보다 slice를 사용한다.

	var x []int
	//var x [5]int : 배열
	//배열과 생김새가 비슷하지만, 길이를 정하지 않는다는 점을 보아 배열과 슬라이스를 구분할 수 있다.
	//슬라이스는 배열과 다르게 길이가 불분명하므로, zero value를 할당할 수 없다. 따라서 값이 없는 경우는 'nil'이 할당된다.
	fmt.Println("x와 nil :", x == nil) //true

	x2 := []int{1, 2, 3}
	fmt.Println("x2 : ", x2) // [1 2 3]
	// 리터럴을 사용한 초기값과 함께 슬라이스 생성

	x3 := []int{}
	//x3는 값이 할당되었기 때문에 nil이 아닌, 길이가 0인 slice
	//nil slice와 길이가 0인 empty slice는 다름.
	fmt.Println("x3과 nil :", x3 == nil) //false

	x4 := make([]int, 5)
	//특정 길이에 zero value를 주고 싶다면, make를 사용
	//x4는 5라는 길이가 주어졌으므로 길이가 5인 슬라이스에 int의 zero value인 0으로 슬라이스가 채워짐.

	fmt.Println("x4 :", x4) // [0 0 0 0 0]

	x5 := make([]int, 5, 10)
	//make의 세 번째 매개변수는 슬라이스의 최대 길이

	fmt.Println("len(x5) :", len(x5), ",cap(x5) :", cap(x5)) //5 10
	//len()은 길이를, cap()은 용량을 나타낸다.
	x5[0] = 1
	x5[1] = 2

	for i := 0; i < len(x5); i++ {
		x5[i] = i + 1
	}

	for j, v := range x5 {
		fmt.Println("x5[", j, "] =" +
			"", v)
		//0 1
		//1 2
		//2 3
		//3 4
		//4 5
	}

	//슬라이싱의 개념은 다음과 같다.
	//x5[a:b] 일 경우, a 이상 b 미만의 인덱스들을 슬라이싱 한다.
	//x5[:b]일 경우, b 미만의 인덱스들을 슬라이싱 한다.
	//x5[a:]일 경우 a부터 끝까지 인덱스들을 슬라이싱한다.

	fmt.Println("x5[0:] :", x5[0:]) // [1 2 3 4 5]
	//0번째부터 끝까지 출력
	fmt.Println("x5[:4] :", x5[:4]) // [1 2 3 4]
	//3 미만의 인덱스들을 출력
	fmt.Println("x5[1:3] :", x5[1:3]) // [2 3]
	//2 이상, 4 미만의 인덱스들 출력
}
